\documentclass[12pt,a4paper]{article}

% --- Packages de base ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath, amssymb}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=2.5cm}

% --- Mise en page des titres (Couleur et Soulignement) ---
\usepackage{titlesec}
\usepackage{ulem}

\definecolor{myblue}{RGB}{0, 51, 153}

\titleformat{\section}
  {\color{myblue}\normalfont\Large\bfseries\fillast}
  {\thesection}{1em}{\uline}

\titleformat{\subsection}
  {\color{myblue}\normalfont\large\bfseries}
  {\thesubsection}{1em}{\uline}

% --- Configuration pour le code Python ---
\usepackage{listings}
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{green!50!black},
    breaklines=true,
    frame=single,
    showstringspaces=false
}

% --- Informations du document ---
\title{Rapport de Projet MIDL 1 \\ \large Élimination de quantificateurs dans la théorie DO}
\author{Dalla-Costa Valentin \& Elissalde Baptiste}
\date{22407035 \& ...}

\begin{document}

\maketitle

\section{Introduction}
% Consigne : décrire le problème sans détails techniques, résumé du travail [cite: 61]
\textit{Rédigez ici votre introduction (environ 1/3 ou 1/2 page). Expliquez que le projet porte sur l'implantation de la procédure d'élimination de quantificateurs pour la théorie des ordres denses (DO)[cite: 7, 8].}

\vspace{1cm}
\textbf{Statut du projet :}
\begin{itemize}
    \item Lot 1 (Obligatoire) : [En cours / Terminé]
    \item Lot 2 (Arithmétique) : [À préciser]
    \item Éléments non réalisés : [Lister ici les éventuelles difficultés rencontrées]
\end{itemize}

\section{Manuel d'utilisateur}

Pour utiliser le programme, assurez-vous de posséder les FICHIERKFGKFGKF dans le même répertoire.

\begin{enumerate}
    \item Lancez une console Python dans ce répertoire.
    \item Lancer le programme principal avec la commande \textbf{\textit{python3 main.py}} (sous python 3).
    \item A partir de là vous pouvez désormais choisir parmi les trois choix possibles, le 1, les tests, on vous demandera ensuite quel test exécuter. Ou alors vous pouvez directement choisir de lancer le programme principal de la procédure de décision avec sois en choix n°2 une formule déjà donné, sois en choix n°3 une formule que vous entrerez vous même.
    \item Dans le cas de ce troisième choix vous entrerez votre formule en suivant les instructions de construction de formule, ensuite cela reviendra au deuxième choix avec la résolution si possible de la formule à l'aide de la procédure de décision.
\end{enumerate}

\section{Description de l'implantation}

\subsection{Représentation des données}

Durant toute la première partie de notre programme, c'est à dire des tests des fonctions de bases jusqu'à la fin des vérifications des hypothèses, nous utiliserons la représentation classique sous forme de formule de logique.\\

Notre représentation des données changera donc après cette dernière étape, nous allons donc utiliser à partir de l'élimination des quantificateurs depuis l'intérieur jusqu'à la fin de notre procédure de décision une tout autre représentation.

Nous avons eu une première idée basée sur deux dictionnaires que nous avons approfondie mais nous nous sommes rendu compte que celle ci était trop compliqué à mettre en place dans la suite du programme, on vous la laisse donc en annexe de ce rapport avant de vous expliciter notre choix final.\\

Tout d'abord comme suggéré dans le sujet nous aurons une liste avec les variables de notre formule qui seront alors chacune associée à un quantificateur existentiel car les hypothèses pour la procédure de décision seront déjà satisfaites à cette étape. Par exemple pour la formule suivante $\exists x\,\exists y\,\varphi$ nous aurons la liste [x,y] dans cette ordre pour pouvoir éliminer les quantificateurs à partir du dernier élément de la liste jusqu'au premier. De ce fait nous pourrons passer en paramètre de certaine de nos fonctions seulement le corps de la fonction, ce qui simplifiera le code de celle-ci.

Cet ordre est simplement pour une meilleure compréhension car en python nous pouvons accéder facilement au dernier élément d'une liste, sinon nous aurons inversé l'ordre pour l'utiliser comme une pile en ajoutant les variables à partir du début de la formule. De même, la liste ne sera pas exactement celle-ci mais plutôt [sub=QuantifF(q=Ex(), var='x', body=None), QuantifF(q=Ex(), var='y', body=None)], de ce fait nous pourrons rajouter les négations dans cette liste.\\

Ensuite lorsque nous arriverons à la dernière étape de notre procédé de prétraitement nous devons tirer la quantification existentielle à l'intérieur de nos disjonctions, car à partir de cette étape nous avons une formule qui est sous forme normale disjonctive. De ce fait nous aurons l'apparition d'une deuxième liste qui sera composée pour chacun de ses éléments, des quantificateurs et de leur potentielle négation ainsi que d'une conjonction de relation. Notre liste sera alors en quelque sorte une disjonction de sous formule (ici des conjoction) extraites de notre formule.
\[
Liste \leftrightarrow\; \bigvee_j (\exists x\, \psi_j)
\]
Nous pouvons apparenter la virgule entre les termes de la liste comme des disjonctions.


\subsection{Implantation de la procédure de décision}

\subsubsection{Hypothèse}

Pour l'implantation de la procédure de décision on a suivi les instructions de la partie A.2 du sujet. Donc tout d'abord nous avons dû émettre des hypothèses sur notre formule que nous avons traduit par des fonctions crées dans notre code.

Celle-ci ne peuvent être exécutés seulement si la formule est close, c'est à dire sans variables libres et qu'elle est composé seulement de symboles relationnels (< et =). 
Nous avons traduit cela dans le code par les fonctions \texttt{freeVar(f)}, \texttt{isClose(f)}, \texttt{toClose(f)}, \texttt{isJustSymboleRelationnel(f)} et \texttt{isElimPossible(f)} qui les utilisent. Toutes celles-ci sont décrite dans la partie \textbf{Analyse des fonctions}. \\


Une fois toutes les exigences satisfaites nous pouvons commencer la démarche nous permettant de satisfaire toute les hypothèses nécessaire à la procédure de décision :

\begin{itemize}
    \item Tout d'abord nous devons convertir la formule en forme prénexe, c'est à dire que tout ses quantificateurs sont situé à gauche de la formule, cela empêche d'avoir plusieurs variable de même nom mais de signification différentes. Pour cela nous avons créé la fonction \texttt{isPrenexe(f)} qui vérifie seulement si notre formule est sous forme prénexe, cela est supposé mais on l'appellera quand même pour suivre la démarche lors du programme principal.\\
    \item Ensuite nous devons convertir les quantificateurs universels en existentiels en suivant la formule suivante : $\forall x. \varphi \leftrightarrow \neg (\exists x. \neg \varphi)$.
    La fonction \texttt{allToExist(f)} suit cette formule et renvoie donc notre formule modifié.\\
    \item Puis pour finir nous pouvons éliminer les quantificateurs à partir de l’intérieur. A partir de cette étape et pour toute la suite de notre programme nous utiliserons le deuxième type de représentation des données, n'étant plus des formules mais des listes. Celle-ci est expliqué plus haut dans la partie \textbf{Représentation des données}.

    Donc nous allons créer pour nous aider les fonctions \texttt{extraireQuantificateurs(f)} et \texttt{reconstruireAvecQuantificateurs(f,quantif)} qui respectivement extrairont les quantificateurs de la formule et reconstruiront la formule à l'aide d'une telle liste. Leurs fonctionnement sont expliqués plus bas.
\end{itemize}

\subsubsection{Prétraitement}

Dans cette partie nous avons désormais une formule qui remplit toute les hypothèses et donc nous pouvons procéder à son prétraitement. Pour cela commençons par tirer les négations à l'intérieur de notre formule, le but de cette étape est de nous retrouver avec une formule sous forme normale négative. Pour cela nous avions déjà créé la fonction \texttt{nnf(f)} lors de la première partie du projet, nous allons donc la reprendre pour construire notre fonction \texttt{tirerNegation(f)}. Nous expliquons sont fonctionnement dans la partie \textbf{Analyse des fonctions}. \\

Ensuite, une fois les négations tirées à l'intérieur de la formule, nous pouvons les supprimer le plus possible. Pour cela nous nous aidons des lois données dans le sujet qui sont : \[
\begin{aligned}
(a)\ &\neg (z \prec z') \leftrightarrow (z = z' \lor z' \prec z) \\
(b)\ &\neg (z = z') \leftrightarrow (z \prec z' \lor z' \prec z)
\end{aligned}\] 

à l'aide de celles-ci nous pouvons créer la fonction \texttt{elimNegation(f)} qui nous renverra le corps de la formule f avec le moins de négation possible.\\

De ce fait, nous pouvons transformer notre formule en forme normale disjonctive pour faciliter la procédure de décision. Pour cela nous avons déjà la fonction \texttt{dnf(f)} qui prend une formule sans quantificateur et renvoie celle-ci sous forme normale disjonctive. Nous créons donc simplement une formule \texttt{toDisjonctive(f)} qui enlèvera les quantificateurs de la formule avant d'y appliquer notre fonction \texttt{dnf(f)}. \\

Pour la dernière étape du prétraitement et comme expliqué dans la partie méthodologie nous allons créer une foction qui nous renvoie une nouvelle liste, celle qui représentera notre forme normale disjonctive sous la forme de sous formule composée exclusivement de conjonction. Le but de cette fonction que nous appellerons \texttt{tirerQuantif(f)}, est de donner cette forme à notre formule : $\bigvee_j (\exists x\, \psi_j)$. Les termes de cette disjonction étant chacun des éléments de notre nouvelle liste, les $\psi_j$ sont eux un ensemble d'aucune ou de plusieurs conjoctions.


\subsection{Analyse des fonctions}
Voici la liste des fonctions actuellement implantées dans les fichiers (\texttt{fonctions\dots.py}) ainsi que leur fonctionnement :

\subsubsection{Fonctions de base}
\begin{itemize}
    \item \textbf{dual(f)} : Parcourt récursivement l'arbre syntaxique pour inverser les opérateurs $\wedge$ et $\vee$.
    \item \textbf{nnf(f)} : Transforme une formule en Forme Normale Négative en descendant les négations jusqu'aux comparaisons.
    \item \textbf{dnf(f)} : Convertit la formule en Forme Normale Disjonctive en utilisant la distributivité.
    \item \textbf{extraireQuantificateurs(f)} : Dans cette fonction itérative nous parcourons la formule dans une boucle "while" comportant 3 tests (il y a un quantificateur, un quantificateur précédé d'une négation ou deux négation à la suite). S'il y a deux négations alors on les supprime et on continue l'algorithme, sinon on ajoute dans une liste créé auparavant le quantificateur précédé ou non d'une négation.
    \item \textbf{reconstruireAvecQuantificateurs(body, quantif)} : Cette fonction plus simple recompose seulement notre formule à l'aide du corps et des quantificateurs, une boucle "for" parcoure la liste de quantificateur à l'envers et ajoute l'élément au début du corps déjà donné.
\end{itemize}

\subsubsection{Fonctions d'aide pour la procédure de décision}
\textbf{Fonctions de vérification des hypothèses :}
\begin{itemize}
    \item \textbf{isClose(f)} : Récupère la liste des variables libres avec \textbf{freeVar(f)}, s'il n'y en a pas alors la formule est close sinon elle ne l'est pas.
    \item \textbf{toClose(f)} : Transforme une formule en formule close en ajoutant un quantificateur $\forall$ pour chaque variable libre.
    \item \textbf{freeVar(f)} : Parcourt récursivement l'arbre syntaxique en ajoutant les variables liées dans un ensemble quelle renvoie ensuite.
    \item \textbf{isJustSymboleRelationnel(f)} : Parcourt récursivement l'arbre syntaxique de la formule et vérifie si elle est composée seulement de symboles relationnels en parcourant l'arbre syntaxique.
    \item \textbf{isElimPossible(f)} : Vérifie si la formule est close et qu'avec des symboles relationnels.
    \item \textbf{isPrenexe(f)} : On vérifie que la formule sois sous la forme prénexe à l'aide d'une fonction qui renvoie si oui ou non une formule contient des quantificateurs. Tant qu ela formule commence par un quantificateur on appelle récursivement sur son contenue et sinon le reste de la formule ne doit pas contenir de quantificateur.
    \item \textbf{allToExist(f)} : Cette fonction se base seulement sur cette formule ($\forall x. \varphi \leftrightarrow \neg (\exists x. \neg \varphi)$) et l'applique à la formule donnée.\\
\end{itemize}

\textbf{Fonctions de prétraitement :}

\begin{itemize}
    \item \textbf{tirerNegation(f)} : Comme nous l'avons dit précédemment nous allons nous aider de la fonction \textbf{nnf(f)} pour cette fonction là. Pour cela le seul enjeu est de donner la formule sans quantificateurs à notre sous fonction \textbf{nnf(f)}, ce qui se fait simplement avec la fonction \textbf{extraireQuantificateurs(f)}. Une fois fait nous pouvons appliquer \textbf{nnf(f)}.
    \item \textbf{elimNegation(f)} : En utilisant les formules de négation cette formule parcourt l'arbre syntaxique de f pour remplacer le corps d'une négation en suivant la formule si cela est possible. Nous avons donc 2 cas pour les 2 implications de celles-ci. Plus un cas pour la double négation que l'on simplifiera.
    \item \textbf{toDisjonctive(f)} : Tout comme pour \textbf{tirerNegation(f)} nous avons simplement à séparer le corps de la formule de ses quantificateurs avec \textbf{extraireQuantificateurs(f)} puis nous appliquons notre fonction \textbf{dnf(f)}. A cette fonction sera associé \textbf{isDisjonctive(f)} qui vérifie si notre formule est bien sous forme normale disjonctive.
    \item \textbf{isDisjonctive(f)} : Parcoure notre formule et vérifie si celle-ci est bien une disjonction de conjonctions. Autrement dit qu'il n'y a pas de disjonction dans une suite de conjonctions et que les deux cotés d'une disjonction sont des formes normales disjonctives.
    \item \textbf{tirerQuantif(f)} : # Comme on ne peut pas voir de négation devant la sous of
\end{itemize}















\section{Extensions (Lots 2 et 3)}
% Consigne : sections supplémentaires pour les options 

\subsection{Extension à l'arithmétique des rationnels (Lot 2)}
[INSÉREZ ICI vos recherches théoriques sur l'isolation des variables dans les expressions linéaires de type $3*x - z < y$ (Tâche 4)[cite: 208, 210].]

\subsection{Preuve constructive (Lot 3)}
[INSÉREZ ICI votre réflexion sur la stratégie de jeu entre l'ordinateur et l'humain (Tâche 6)[cite: 226, 234].]

\appendix
\section{Code source (Extraits)}
\begin{lstlisting}[caption={Extrait des fonctions de base}]
def nnf(f: Formula) -> Formula:
    # Retourne la forme normale négative
    if isinstance(f, ConstF) or isinstance(f, ComparF):
        return f
    # ... (suite du code)
\end{lstlisting}

\subsection{Développement des nouvelles fonctions : Élimination de variable}

L'étape cruciale du projet consiste à éliminer un quantificateur existentiel de type $\exists x. \phi$, où $\phi$ est une conjonction de littéraux (comparaisons). Cette étape repose sur l'idée que dans un ordre dense, l'existence de $x$ est garantie par les relations entre les bornes inférieures et supérieures.

\subsubsection{Algorithme de suppression de variable}
Pour supprimer la variable $x$ d'une conjonction de comparaisons, nous suivons la procédure suivante :
\begin{enumerate}
    \item \textbf{Filtrage :} On sépare les formules en trois ensembles :
    \begin{itemize}
        \item $L$ (Lower) : les éléments $a$ tels que $a < x$.
        \item $U$ (Upper) : les éléments $b$ tels que $x < b$.
        \item $R$ (Rest) : les formules ne contenant pas $x$.
    \end{itemize}
    \item \textbf{Combinaison :} La formule résultante est $\left( \bigwedge_{a \in L, b \in U} a < b \right) \wedge R$.
\end{enumerate}

\subsubsection{Fonctions à implanter}
Voici les fonctions que nous avons prévues pour compléter le Lot 1 :

\begin{itemize}
    \item \texttt{collect\_bounds(f, x)} : Parcourt une conjonction et retourne les listes $L$ et $U$.
    \item \texttt{remove\_quantifier(f)} : La fonction principale qui prend une formule $\exists x. \phi$, transforme $\phi$ en DNF, et applique l'élimination sur chaque clause.
\end{itemize}

\begin{lstlisting}[caption={Structure cible pour l'élimination de variable}]
def solve_exists_x(conjunction, x):
    """
    Entree : Une liste de comparaisons (clause de DNF)
    Sortie : Une nouvelle formule sans la variable x
    """
    lower_bounds = [] # Elements 'a' tels que a < x
    upper_bounds = [] # Elements 'b' tels que x < b
    others = []       # Formules sans x
    
    # 1. Analyse de la clause
    # TODO: Parcourir conjunction et remplir les listes
    
    # 2. Generation des nouvelles contraintes (a < b)
    new_constraints = []
    for a in lower_bounds:
        for b in upper_bounds:
            new_constraints.append(ltf(a, b))
            
    # 3. Retourner la conjonction finale
    # return conj_list(new_constraints + others)
\end{lstlisting}



\section{Annexe}

Elle sera composé d'une liste et de deux dictionnaires dont on va vous expliquer l'utilité :
\begin{itemize}
    \item Tout d'abord comme suggéré dans le sujet nous aurons une liste avec les variables de notre formule qui seront alors chacune associée à un quantificateur existentiel car les hypothèses pour la procédure de décision seront déjà satisfaites à cette étape. Par exemple pour la formule suivante $\exists x\,\exists y\,\exists z\,\varphi$ nous aurons la liste [x,y,z] dans cette ordre pour pouvoir éliminer les quantificateurs à partir du dernier élément de la liste jusqu'au premier. Cet ordre est simplement pour une meilleure compréhension car en python nous pouvons accéder facilement au dernier élément d'une liste, sinon nous aurons inversé l'ordre pour l'utiliser comme une pile en ajoutant les variables à partir du début de la formule. De même, la liste ne sera pas exactement celle-ci mais plutôt [sub=QuantifF(q=Ex(), var='x', body=None), QuantifF(q=Ex(), var='y', body=None), QuantifF(q=Ex(), var='z', body=None)], de ce fait nous pourrons rajouter les négations dans cette liste.\\
\end{itemize}

Ensuite nous avons penser à une suite de cette représentation qui sera possible juste après avoir tiré les négations à l'intérieur de notre formule. Nous aurons besoin deux dictionnaires pour cela :

\begin{itemize}
    \item Le premier dictionnaire que nous appellerons dicoEqual sera composé de toute les égalités de la formule ou sous-formule étudié.\\
    \item Dans le même style que le premier nous aurons le dictionnaire dicoLeft qui sera composé de toute les inégalités de la formule ou d'une sous-formule.
\end{itemize}

Pour les cas simple ces deux dictionnaires suffisent mais dès lors que nous aurons des formules constituées de $\lor$ et de $\land$ nous devrons séparer notre formule en sous formule pour les résoudre les unes après les autres. 
Lorsque nous rencontrons un $\land$ nous pouvons mettre l'égalité ou l'inégalité dans le même dictionnaire mais si nous avons un $\lor$ il faut alors extraire les deux sous formules et créer les deux dictionnaires pour chacun afin de résoudre cela.

\end{document}