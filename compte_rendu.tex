\documentclass[12pt,a4paper]{article}

% --- Packages de base ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath, amssymb}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=2.5cm}

% --- Mise en page des titres (Couleur et Soulignement) ---
\usepackage{titlesec}
\usepackage{ulem}

\definecolor{myblue}{RGB}{0, 51, 153}

\titleformat{\section}
  {\color{myblue}\normalfont\Large\bfseries\fillast}
  {\thesection}{1em}{\uline}

\titleformat{\subsection}
  {\color{myblue}\normalfont\large\bfseries}
  {\thesubsection}{1em}{\uline}

% --- Configuration pour le code Python ---
\usepackage{listings}
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{green!50!black},
    breaklines=true,
    frame=single,
    showstringspaces=false
}

% --- Informations du document ---
\title{Rapport de Projet MIDL 1 \\ \large Élimination de quantificateurs dans la théorie DO}
\author{Dalla-Costa Valentin \& Elissalde Baptiste}
\date{22407035 \& ...}

\begin{document}

\maketitle

\section{Introduction}
% Consigne : décrire le problème sans détails techniques, résumé du travail [cite: 61]
\textit{Rédigez ici votre introduction (environ 1/3 ou 1/2 page). Expliquez que le projet porte sur l'implantation de la procédure d'élimination de quantificateurs pour la théorie des ordres denses (DO)[cite: 7, 8].}

\vspace{1cm}
\textbf{Statut du projet :}
\begin{itemize}
    \item Lot 1 (Obligatoire) : [En cours / Terminé]
    \item Lot 2 (Arithmétique) : [À préciser]
    \item Éléments non réalisés : [Lister ici les éventuelles difficultés rencontrées]
\end{itemize}

\section{Manuel d'utilisateur}

Pour utiliser le programme, assurez-vous de posséder les FICHIERKFGKFGKF dans le même répertoire.

\begin{enumerate}
    \item Lancez une console Python dans ce répertoire.
    \item Lancer le programme principal avec la commande \textbf{\textit{python3 main.py}} (sous python 3).
    \item A partir de là vous pouvez désormais choisir parmi les trois choix possibles, le 1, les tests, on vous demandera ensuite quel test exécuter. Ou alors vous pouvez directement choisir de lancer le programme principal de la procédure de décision avec sois en choix n°2 une formule déjà donné, sois en choix n°3 une formule que vous entrerez vous même.
    \item Dans le cas de ce troisième choix vous entrerez votre formule en suivant les instructions de construction de formule, ensuite cela reviendra au deuxième choix avec la résolution si possible de la formule à l'aide de la procédure de décision.
\end{enumerate}

\section{Description de l'implantation}

\subsection{Représentation des données}

Durant toute la première partie de notre programme, c'est à dire des tests des fonctions de bases jusqu'à la fin des vérifications des hypothèses, nous utiliserons la représentation classique sous forme de formule classique de logique. \\
Notre représentation des données changera donc après cette dernière étape, nous allons donc utiliser à partir de l'élimination des quantificateurs depuis l'intérieur jusqu'à la fin de notre procédure de décision une tout autre représentation. 

Elle sera composé d'une liste et de deux dictionnaires dont on va vous expliquer l'utilité :
\begin{itemize}
    \item Tout d'abord comme suggéré dans le sujet nous aurons une liste avec les variables de notre formule qui seront alors chacune associée à un quantificateur existentiel car les hypothèses pour la procédure de décision seront déjà satisfaites à cette étape. Par exemple pour la formule suivante $\exists x\,\exists y\,\exists z\,\varphi$ nous aurons la liste [x,y,z] dans cette ordre pour pouvoir éliminer les quantificateurs à partir du dernier élément de la liste jusqu'au premier. Cet ordre est simplement pour une meilleure compréhension car en python nous pouvons accéder facilement au dernier élément d'une liste, sinon nous aurons inversé l'ordre pour l'utiliser comme une pile en ajoutant les variables à partir du début de la formule.\\
\end{itemize}

Ensuite nous avons penser à une suite de cette représentation qui sera possible juste après avoir tiré les négations à l'intérieur de notre formule. Nous aurons besoin deux dictionnaires pour cela :

\begin{itemize}
    \item Le premier dictionnaire que nous appellerons dicoEqual sera composé de toute les égalités de la formule ou sous-formule étudié.\\
    \item Dans le même style que le premier nous aurons le dictionnaire dicoLeft qui sera composé de toute les inégalités de la formule ou d'une sous-formule.
\end{itemize}

Pour les cas simple ces deux dictionnaires suffisent mais dès lors que nous aurons des formules constituées de $\lor$ et de $\land$ nous devrons séparer notre formule en sous formule pour les résoudre les unes après les autres. 
Lorsque nous rencontrons un $\land$ nous pouvons mettre l'égalité ou l'inégalité dans le même dictionnaire mais si nous avons un $\lor$ il faut alors extraire les deux sous formules et créer les deux dictionnaires pour chacun afin de résoudre cela.

\subsection{Implantation de la procédure de décision}

\subsubsection{Hypothèse}

Pour l'implantation de la procédure de décision on a suivi les instructions de la partie A.2 du sujet. Donc tout d'abord nous avons dû émettre des hypothèses sur notre formule que nous avons traduit par des fonctions crées dans notre code.

Celle-ci ne peuvent être exécutés seulement si la formule est close, c'est à dire sans variables libres et qu'elle est composé seulement de symboles relationnels (< et =). 
Nous avons traduit cela dans le code par les fonctions \texttt{freeVar(f)}, \texttt{isClose(f)}, \texttt{toClose(f)}, \texttt{isJustSymboleRelationnel(f)} et \texttt{isElimPossible(f)} qui les utilisent. Toutes celles-ci sont décrite dans la partie \textbf{Analyse des fonctions}. \\


Une fois toutes les exigences satisfaites nous pouvons commencer la démarche nous permettant de satisfaire toute les hypothèses nécessaire à la procédure de décision :

\begin{itemize}
    \item Tout d'abord nous devons convertir la formule en forme prénexe, c'est à dire que tout ses quantificateurs sont situé à gauche de la formule, cela empêche d'avoir plusieurs variable de même nom mais de signification différentes. Pour cela nous avons créé la fonction \texttt{isPrenexe(f)} qui vérifie seulement si notre formule est sous forme prénexe, cela est supposé mais on l'appellera quand même pour suivre la démarche lors du programme principal.\\
    \item Ensuite nous devons convertir les quantificateurs universels en existentiels en suivant la formule suivante : $\forall x. \varphi \leftrightarrow \neg (\exists x. \neg \varphi)$.
    La fonction \texttt{allToExist(f)} suit cette formule et renvoie donc notre formule modifié.\\
    \item Puis pour finir nous pouvons éliminer les quantificateurs à partir de l’intérieur. A partir de cette étape et pour toute la suite de notre programme nous utiliserons le deuxième type de représentation des données, n'étant plus des formules mais des listes. Celle-ci est expliqué plus haut dans la partie \textbf{Représentation des données}.
    CGJDHJHNK?L.M/L.L?KNJBHVTFGDSGHJKLMK FGFDHHDF
\end{itemize}

\subsubsection{Prétraitement}

Dans cette partie nous avons désormais une formule qui remplit toute les hypothèses et donc nous pouvons procéder au prétraitement de notre formule. Pour cela commençons par tirer les négations à l'intérieur de notre formule, pour nous aider nous avons deux formules importantes, qui sont : \[
\begin{aligned}
(a)\ &\neg (z \prec z') \leftrightarrow (z = z' \lor z' \prec z) \\
(b)\ &\neg (z = z') \leftrightarrow (z \prec z' \lor z' \prec z)
\end{aligned}
\] à l'aide de celles-ci nous pouvons créer la fonction \texttt{tirerNegation(f)} qui nous renverra la formule f avec les négations tirées vers l'intérieur.


\subsection{Analyse des fonctions}
Voici la liste des fonctions actuellement implantées dans les fichiers (\texttt{fonctions\dots.py}) ainsi que leur fonctionnement :

\subsubsection{Fonctions de base}
\begin{itemize}
    \item \textbf{dual(f)} : Parcourt récursivement l'arbre syntaxique pour inverser les opérateurs $\wedge$ et $\vee$.
    \item \textbf{nnf(f)} : Transforme une formule en Forme Normale Négative en descendant les négations jusqu'aux comparaisons.
    \item \textbf{dnf(f)} : Convertit la formule en Forme Normale Disjonctive en utilisant la distributivité.
\end{itemize}

\subsubsection{Fonctions d'aide pour la procédure de décision}
\textbf{Fonctions de vérification des hypothèses :}
\begin{itemize}
    \item \textbf{isClose(f)} : Récupère la liste des variables libres avec \textbf{freeVar(f)}, s'il n'y en a pas alors la formule est close sinon elle ne l'est pas.
    \item \textbf{toClose(f)} : Transforme une formule en formule close en ajoutant un quantificateur $\forall$ pour chaque variable libre.
    \item \textbf{freeVar(f)} : Parcourt récursivement l'arbre syntaxique en ajoutant les variables liées dans un ensemble quelle renvoie ensuite.
    \item \textbf{isJustSymboleRelationnel(f)} : Parcourt récursivement l'arbre syntaxique de la formule et vérifie si elle est composée seulement de symboles relationnels en parcourant l'arbre syntaxique.
    \item \textbf{isElimPossible(f)} : Vérifie si la formule est close et qu'avec des symboles relationnels.
    \item \textbf{isPrenexe(f)} : On vérifie que la formule sois sous la forme prénexe à l'aide d'une fonction qui renvoie si oui ou non une formule contient des quantificateurs. Tant qu ela formule commence par un quantificateur on appelle récursivement sur son contenue et sinon le reste de la formule ne doit pas contenir de quantificateur.
    \item \textbf{allToExist(f)} : Cette fonction se base seulement sur cette formule ($\forall x. \varphi \leftrightarrow \neg (\exists x. \neg \varphi)$) et l'applique à la formule donnée.
    \item \textbf{tirerNegation(f)} : En utilisant les formules de négation cette formule parcourt l'arbre syntaxique de f pour remplacer le corps d'une négation en suivant la formule si cela est possible. Nous avons donc 4 cas pour les 4 implications de celles-ci.  
\end{itemize}


\section{Extensions (Lots 2 et 3)}
% Consigne : sections supplémentaires pour les options 

\subsection{Extension à l'arithmétique des rationnels (Lot 2)}
[INSÉREZ ICI vos recherches théoriques sur l'isolation des variables dans les expressions linéaires de type $3*x - z < y$ (Tâche 4)[cite: 208, 210].]

\subsection{Preuve constructive (Lot 3)}
[INSÉREZ ICI votre réflexion sur la stratégie de jeu entre l'ordinateur et l'humain (Tâche 6)[cite: 226, 234].]

\appendix
\section{Code source (Extraits)}
\begin{lstlisting}[caption={Extrait des fonctions de base}]
def nnf(f: Formula) -> Formula:
    # Retourne la forme normale négative
    if isinstance(f, ConstF) or isinstance(f, ComparF):
        return f
    # ... (suite du code)
\end{lstlisting}

\subsection{Développement des nouvelles fonctions : Élimination de variable}

L'étape cruciale du projet consiste à éliminer un quantificateur existentiel de type $\exists x. \phi$, où $\phi$ est une conjonction de littéraux (comparaisons). Cette étape repose sur l'idée que dans un ordre dense, l'existence de $x$ est garantie par les relations entre les bornes inférieures et supérieures.

\subsubsection{Algorithme de suppression de variable}
Pour supprimer la variable $x$ d'une conjonction de comparaisons, nous suivons la procédure suivante :
\begin{enumerate}
    \item \textbf{Filtrage :} On sépare les formules en trois ensembles :
    \begin{itemize}
        \item $L$ (Lower) : les éléments $a$ tels que $a < x$.
        \item $U$ (Upper) : les éléments $b$ tels que $x < b$.
        \item $R$ (Rest) : les formules ne contenant pas $x$.
    \end{itemize}
    \item \textbf{Combinaison :} La formule résultante est $\left( \bigwedge_{a \in L, b \in U} a < b \right) \wedge R$.
\end{enumerate}

\subsubsection{Fonctions à implanter}
Voici les fonctions que nous avons prévues pour compléter le Lot 1 :

\begin{itemize}
    \item \texttt{collect\_bounds(f, x)} : Parcourt une conjonction et retourne les listes $L$ et $U$.
    \item \texttt{remove\_quantifier(f)} : La fonction principale qui prend une formule $\exists x. \phi$, transforme $\phi$ en DNF, et applique l'élimination sur chaque clause.
\end{itemize}

\begin{lstlisting}[caption={Structure cible pour l'élimination de variable}]
def solve_exists_x(conjunction, x):
    """
    Entree : Une liste de comparaisons (clause de DNF)
    Sortie : Une nouvelle formule sans la variable x
    """
    lower_bounds = [] # Elements 'a' tels que a < x
    upper_bounds = [] # Elements 'b' tels que x < b
    others = []       # Formules sans x
    
    # 1. Analyse de la clause
    # TODO: Parcourir conjunction et remplir les listes
    
    # 2. Generation des nouvelles contraintes (a < b)
    new_constraints = []
    for a in lower_bounds:
        for b in upper_bounds:
            new_constraints.append(ltf(a, b))
            
    # 3. Retourner la conjonction finale
    # return conj_list(new_constraints + others)
\end{lstlisting}

\end{document}