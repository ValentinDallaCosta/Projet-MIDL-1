\UseRawInputEncoding
\documentclass[12pt,a4paper]{article}

% --- Packages de base ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath, amssymb}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=2.5cm}

% --- Mise en page des titres (Couleur et Soulignement) ---
\usepackage{titlesec}
\usepackage{ulem}

\definecolor{myblue}{RGB}{0, 51, 153}

\titleformat{\section}
  {\color{myblue}\normalfont\Large\bfseries\fillast}
  {\thesection}{1em}{\uline}

\titleformat{\subsection}
  {\color{myblue}\normalfont\large\bfseries}
  {\thesubsection}{1em}{\uline}

% --- Configuration pour le code Python ---
\usepackage{listings}
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{green!50!black},
    breaklines=true,
    frame=single,
    showstringspaces=false
}

% --- Informations du document ---
\title{Rapport de Projet MIDL 1 \\ \large Élimination de quantificateurs dans la théorie DO}
\author{Dalla-Costa Valentin \& Elissalde Baptiste}
\date{22407035 \& ...}

\begin{document}

\maketitle

\section{Introduction}
% Consigne : décrire le problème sans détails techniques, résumé du travail [cite: 61]
\textit{Rédigez ici votre introduction (environ 1/3 ou 1/2 page). Expliquez que le projet porte sur l'implantation de la procédure d'élimination de quantificateurs pour la théorie des ordres denses (DO)[cite: 7, 8].}

\vspace{1cm}
\textbf{Statut du projet :}
\begin{itemize}
    \item Lot 1 (Obligatoire) : [En cours / Terminé]
    \item Lot 2 (Arithmétique) : [À préciser]
    \item Éléments non réalisés : [Lister ici les éventuelles difficultés rencontrées]
\end{itemize}

\section{Manuel d'utilisateur}

Pour utiliser le programme, assurez-vous de posséder les FICHIERKFGKFGKF dans le même répertoire.

\begin{enumerate}
    \item Lancez une console Python dans ce répertoire.
    \item Lancer le programme principal avec la commande \textbf{\textit{python3 main.py}} (sous python 3).
    \item A partir de là vous pouvez désormais choisir parmi les trois choix possibles, le 1, les tests, on vous demandera ensuite quel test exécuter. Ou alors vous pouvez directement choisir de lancer le programme principal de la procédure de décision avec sois en choix n°2 une formule déjà donné, sois en choix n°3 une formule que vous entrerez vous même.
    \item Dans le cas de ce troisième choix vous entrerez votre formule en suivant les instructions de construction de formule, ensuite cela reviendra au deuxième choix avec la résolution si possible de la formule à l'aide de la procédure de décision.
\end{enumerate}

\section{Description de l'implantation}

\subsection{Représentation des données}

Durant toute la première partie de notre programme, c'est à dire des tests des fonctions de bases jusqu'à la fin des vérifications des hypothèses, nous utiliserons la représentation classique sous forme de formule de logique.\\

Notre représentation des données changera donc après cette dernière étape, nous allons donc utiliser à partir de l'élimination des quantificateurs depuis l'intérieur jusqu'à la fin de notre procédure de décision une tout autre représentation.

Nous avons eu une première idée basée sur deux dictionnaires que nous avons approfondie mais nous nous sommes rendu compte que celle ci était trop compliqué à mettre en place dans la suite du programme, on vous la laisse donc en annexe de ce rapport avant de vous expliciter notre choix final.\\

Tout d'abord comme suggéré dans le sujet nous aurons une liste avec les variables de notre formule qui seront alors chacune associée à un quantificateur existentiel car les hypothèses pour la procédure de décision seront déjà satisfaites à cette étape. Par exemple pour la formule suivante $\exists x\,\exists y\,\varphi$ nous aurons la liste [x,y] dans cette ordre pour pouvoir éliminer les quantificateurs à partir du dernier élément de la liste jusqu'au premier. De ce fait nous pourrons passer en paramètre de certaine de nos fonctions seulement le corps de la fonction, ce qui simplifiera le code de celle-ci.

Cet ordre est simplement pour une meilleure compréhension car en python nous pouvons accéder facilement au dernier élément d'une liste, sinon nous aurons inversé l'ordre pour l'utiliser comme une pile en ajoutant les variables à partir du début de la formule. De même, la liste ne sera pas exactement celle-ci mais plutôt [sub=QuantifF(q=Ex(), var='x', body=None), QuantifF(q=Ex(), var='y', body=None)], de ce fait nous pourrons rajouter les négations dans cette liste.\\

Ensuite lorsque nous arriverons à la dernière étape de notre procédé de prétraitement nous devons tirer la quantification existentielle à l'intérieur de nos disjonctions, car à partir de cette étape nous avons une formule qui est sous forme normale disjonctive. De ce fait nous aurons l'apparition d'une deuxième liste qui sera composée pour chacun de ses éléments, des quantificateurs et de leur potentielle négation ainsi que d'une conjonction de relation. Notre liste sera alors en quelque sorte une disjonction de sous formule (ici des conjoction) extraites de notre formule.
\[
Liste \leftrightarrow\; \bigvee_j (\exists x\, \psi_j)
\]
Nous pouvons apparenter la virgule entre les termes de la liste comme des disjonctions.


\subsection{Implantation de la procédure de décision}

\subsubsection{\underline{Hypothèse}}

Pour l'implantation de la procédure de décision on a suivi les instructions de la partie A.2 du sujet. Donc tout d'abord nous avons dû émettre des hypothèses sur notre formule que nous avons traduit par des fonctions crées dans notre code.

Celle-ci ne peuvent être exécutés seulement si la formule est close, c'est à dire sans variables libres et qu'elle est composé seulement de symboles relationnels (< et =). 
Nous avons traduit cela dans le code par les fonctions \texttt{freeVar(f)}, \texttt{isClose(f)}, \texttt{toClose(f)}, \texttt{isJustSymboleRelationnel(f)} et \texttt{isElimPossible(f)} qui les utilisent. Toutes celles-ci sont décrite dans la partie \textbf{Analyse des fonctions}. \\


Une fois toutes les exigences satisfaites nous pouvons commencer la démarche nous permettant de satisfaire toute les hypothèses nécessaire à la procédure de décision :

\begin{itemize}
    \item Tout d'abord nous devons convertir la formule en forme prénexe, c'est à dire que tout ses quantificateurs sont situé à gauche de la formule, cela empêche d'avoir plusieurs variable de même nom mais de signification différentes. Pour cela nous avons créé la fonction \texttt{isPrenexe(f)} qui vérifie seulement si notre formule est sous forme prénexe, cela est supposé mais on l'appellera quand même pour suivre la démarche lors du programme principal.\\
    \item Ensuite nous devons convertir les quantificateurs universels en existentiels en suivant la formule suivante : $\forall x. \varphi \leftrightarrow \neg (\exists x. \neg \varphi)$.
    La fonction \texttt{allToExist(f)} suit cette formule et renvoie donc notre formule modifié.\\
    \item Puis pour finir nous pouvons éliminer les quantificateurs à partir de l’intérieur. A partir de cette étape et pour toute la suite de notre programme nous utiliserons le deuxième type de représentation des données, n'étant plus des formules mais des listes. Celle-ci est expliqué plus haut dans la partie \textbf{Représentation des données}.

    Donc nous allons créer pour nous aider les fonctions \texttt{extraireQuantificateurs(f)} et \texttt{reconstruireAvecQuantificateurs(f,quantif)} qui respectivement extrairont les quantificateurs de la formule et reconstruiront la formule à l'aide d'une telle liste. Leurs fonctionnement sont expliqués plus bas.
\end{itemize}

\subsubsection{\underline{Prétraitement}}

Dans cette partie nous avons désormais une formule qui remplit toute les hypothèses et donc nous pouvons procéder à son prétraitement. Pour cela commençons par tirer les négations à l'intérieur de notre formule, le but de cette étape est de nous retrouver avec une formule sous forme normale négative. Pour cela nous avions déjà créé la fonction \texttt{nnf(f)} lors de la première partie du projet, nous allons donc la reprendre pour construire notre fonction \texttt{tirerNegation(f)}. Nous expliquons sont fonctionnement dans la partie \textbf{Analyse des fonctions}. \\

Ensuite, une fois les négations tirées à l'intérieur de la formule, nous pouvons les supprimer le plus possible. Pour cela nous nous aidons des lois données dans le sujet qui sont : \[
\begin{aligned}
(a)\ &\neg (z \prec z') \leftrightarrow (z = z' \lor z' \prec z) \\
(b)\ &\neg (z = z') \leftrightarrow (z \prec z' \lor z' \prec z)
\end{aligned}\] 

à l'aide de celles-ci nous pouvons créer la fonction \texttt{elimNegation(f)} qui nous renverra le corps de la formule f avec le moins de négation possible.\\

De ce fait, nous pouvons transformer notre formule en forme normale disjonctive pour faciliter la procédure de décision. Pour cela nous avons déjà la fonction \texttt{dnf(f)} qui prend une formule sans quantificateur et renvoie celle-ci sous forme normale disjonctive. Nous créons donc simplement une formule \texttt{toDisjonctive(f)} qui enlèvera les quantificateurs de la formule avant d'y appliquer notre fonction \texttt{dnf(f)}. \\

Pour la dernière étape du prétraitement et comme expliqué dans la partie méthodologie nous allons créer une foction qui nous renvoie une nouvelle liste, celle qui représentera notre forme normale disjonctive sous la forme de sous formule composée exclusivement de conjonction. Le but de cette fonction que nous appellerons \texttt{tirerQuantif(f)}, est de donner cette forme à notre formule : $\bigvee_j (\exists x\, \psi_j)$. Les termes de cette disjonction étant chacun des éléments de notre nouvelle liste, les $\psi_j$ sont eux un ensemble d'aucune ou de plusieurs conjoctions de relations $u \prec v$ ou $u = v$..

A cette étape nous avons donc finie la partie de prétraitement de notre formule, nous avons obtenue à l'arrivé une disjonction de sous formule conjonctive que nous allons désormais pouvoir étudier. Cela dans la partie \textbf{Suppression de variables}.

\subsubsection{\underline{Suppression de variables}}

Dans cette partie nous allons enfin nous focaliser sur la résolution de notre formule, on rappelle que nous avons obtenue par le biais des partie précédente et de leurs modifications sur notre formule générale une liste de sous formule toute composé uniquement de conjonction. Nous pouvons donc désormais traiter chacune d'entre elle à travers de multiples étapes que l'on va vous expliciter.\\

Tout d'abord commençons par les deux premières étapes qui seront les plus simples, la première est de retirer tout les quantificateurs inutiles de notre formule, c'est à dire ceux qui ne concerne aucune variable de notre sous-formule. Par exemple ($\exists y.$) dans $\exists x. \exists y. x = x$. Pour cela nous créerons la fonction \texttt{elimQuantifInutile(f)} qui nous renverras notre liste avec chaque sous-formules démunie de ses quantificateurs inutiles.

Notre deuxième étapes sera de rechercher exactement cette relation (x < x) dans chacune des sous-formules, si elle est présente alors celle-ci sera modifié pour devenir : $\bot$ On nommera cette nouvelle fonction \texttt{supXltX(list)}.

\subsection{Analyse des fonctions}
Voici la liste des fonctions actuellement implantées dans les fichiers (\texttt{fonctions\dots.py}) ainsi que leur fonctionnement :

\subsubsection{Fonctions de base}
\begin{itemize}
    \item \textbf{dual(f)} : Parcourt récursivement l'arbre syntaxique pour inverser les opérateurs $\wedge$ et $\vee$.
    \item \textbf{nnf(f)} : Transforme une formule en Forme Normale Négative en descendant les négations jusqu'aux comparaisons.
    \item \textbf{dnf(f)} : Convertit la formule en Forme Normale Disjonctive en utilisant la distributivité.
    \item \textbf{freeVar(f)} : Parcourt récursivement l'arbre syntaxique en ajoutant les variables liées dans un ensemble quelle renvoie ensuite.
    \item \textbf{extraireQuantificateurs(f)} : Dans cette fonction itérative nous parcourons la formule dans une boucle "while" comportant 3 tests (il y a un quantificateur, un quantificateur précédé d'une négation ou deux négation à la suite). S'il y a deux négations alors on les supprime et on continue l'algorithme, sinon on ajoute dans une liste créé auparavant le quantificateur précédé ou non d'une négation.
    \item \textbf{reconstruireAvecQuantificateurs(body, quantif)} : Cette fonction plus simple recompose seulement notre formule à l'aide du corps et des quantificateurs, une boucle "for" parcoure la liste de quantificateur à l'envers et ajoute l'élément au début du corps déjà donné.
    \item \textbf{allVarInFormula(f)} : Cette fonction nous permet de récupérer les variables de la formule, celle ci nous sera utile dans plusieurs autres fonctions comme \texttt{elimQauntifInutile(list)}. C'est une fonction récursive basée sur plusieurs tests qui soit applique la fonction sur une sous formule soit, si il y a une relation (= ou <), ajoute dans la liste renvoyée les deux variables.
    \item \textbf{affichageListeFormules(formules)} : Cette fonction nous servira dans le programme principal à partir de la dernière partie de notre procédure de décision, c'est à dire lorsque nous manipulons une liste de sous-formules. Elle est facilement composée d'une boucle qui parcourt la liste et en affiche son contenue avec une indexation.
\end{itemize}

\subsubsection{Fonctions d'aide pour la procédure de décision}
\textbf{Fonctions de vérification des hypothèses :}
\begin{itemize}
    \item \textbf{isClose(f)} : Récupère la liste des variables libres avec \textbf{freeVar(f)}, s'il n'y en a pas alors la formule est close sinon elle ne l'est pas.
    \item \textbf{toClose(f)} : Transforme une formule en formule close en ajoutant un quantificateur $\forall$ pour chaque variable libre.
    \item \textbf{isJustSymboleRelationnel(f)} : Parcourt récursivement l'arbre syntaxique de la formule et vérifie si elle est composée seulement de symboles relationnels en parcourant l'arbre syntaxique.
    \item \textbf{isElimPossible(f)} : Vérifie si la formule est close et qu'avec des symboles relationnels.
    \item \textbf{isPrenexe(f)} : On vérifie que la formule sois sous la forme prénexe à l'aide d'une fonction qui renvoie si oui ou non une formule contient des quantificateurs. Tant qu ela formule commence par un quantificateur on appelle récursivement sur son contenue et sinon le reste de la formule ne doit pas contenir de quantificateur.
    \item \textbf{allToExist(f)} : Cette fonction se base seulement sur cette formule ($\forall x. \varphi \leftrightarrow \neg (\exists x. \neg \varphi)$) et l'applique à la formule donnée.\\
\end{itemize}

\textbf{Fonctions de prétraitement :}

\begin{itemize}
    \item \textbf{tirerNegation(f)} : Comme nous l'avons dit précédemment nous allons nous aider de la fonction \textbf{nnf(f)} pour cette fonction là. Pour cela le seul enjeu est de donner la formule sans quantificateurs à notre sous fonction \textbf{nnf(f)}, ce qui se fait simplement avec la fonction \textbf{extraireQuantificateurs(f)}. Une fois fait nous pouvons appliquer \textbf{nnf(f)}.
    \item \textbf{elimNegation(f)} : En utilisant les formules de négation cette formule parcourt l'arbre syntaxique de f pour remplacer le corps d'une négation en suivant la formule si cela est possible. Nous avons donc 2 cas pour les 2 implications de celles-ci. Plus un cas pour la double négation que l'on simplifiera.
    \item \textbf{toDisjonctive(f)} : Tout comme pour \textbf{tirerNegation(f)} nous avons simplement à séparer le corps de la formule de ses quantificateurs avec \textbf{extraireQuantificateurs(f)} puis nous appliquons notre fonction \textbf{dnf(f)}. A cette fonction sera associé \textbf{isDisjonctive(f)} qui vérifie si notre formule est bien sous forme normale disjonctive.
    \item \textbf{isDisjonctive(f)} : Parcoure notre formule et vérifie si celle-ci est bien une disjonction de conjonctions. Autrement dit qu'il n'y a pas de disjonction dans une suite de conjonctions et que les deux cotés d'une disjonction sont des formes normales disjonctives.
    \item \textbf{tirerQuantif(f)} : Cette formule nous est très importante car elle nous permet de séparer notre formule générale en plusieurs sous formules qui seront plus simple à décider. De plus nous partons d'une forme normale disjonctive donc il nous suffit dans cette fonction de récupérer chaque sous formule qui n'est pas composée de disjonction. Pour cela on fait appel à une forme itérative de fonction basée sur un algorithme similaire au parcours d'un arbre binaire en largeur avec une liste. De ce fait, on commence par vérifier si notre formule est une disjonction, si c'est le cas on ajoute ces deux côtés dans notre liste de disjonctions, sinon on ajoute directement la formule entière. Puis nous lançons une boucle qui parcoure notre liste de disjonctions en traitant chaque éléments de celle-ci, si c'est encore une disjonction alors on ajoute de nouveau dans la même liste, sinon on ajoute la conjonction ou simplement la relation dans la liste que nous renverrons.\\
\end{itemize}

\textbf{Fonctions de suppression de variable :}

\begin{itemize}
    \item \textbf{elimQuantifInutile(conjonctions)} : Dans cette fonction nous allons créer une autre fonction qui nous renverra la liste des variables présentes dans notre formule (\texttt{allVarInFormula(f), explication de son fonctionnement dans la partie des fonctions de bases}), ce qui nous permettra ensuite de supprimer les quantificateurs inutiles. 

    Ici toute la difficulté est dans les négations, si un quantificateur est inutile alors on le supprime, rien de compliqué. Mais si celui-ci est précédé d'une négation alors on l'applique sur le quantificateur suivant. Dès lors nous avons 3 cas : Si celui-ci n'a pas déjà de négation alors on la décale devant celui-ci, sinon on supprime la négation (car deux à la suite) et dans le dernier cas, si c'était le dernier quantificateur alors on décale cette négation au corps de la formule. Pour tout ces tests on s'est aidé du booléen \texttt{isNot} qui correspond au manque ou non d'une négation. En aucun cas lors de cette fonction nous supprimons une négation car cela modifierait le sens logique de la formule.
    \item \textbf{supXltX(list)} : Cette fonction prend en paramètre la même liste de conjonction que celle dans les autres fonctions de cette partie de suppression de variable. Ici nous allons donc parcourir la liste passé en paramètre et rechercher l'inégalité (x < x).
    
    Pour cela nous créons la fonction récursive \texttt{searchXltX(f)} qui est locale et définit dans notre fonction car elle ne servira nulle part ailleurs. Nous testons donc pour chaque formule de la liste si elle contient cette relation, si c'est le cas on remplace cette formule par $\bot$ dans la liste et sinon celle-ci reste inchangé.
\end{itemize}

\newpage
\section{Annexe}

Elle sera composé d'une liste et de deux dictionnaires dont on va vous expliquer l'utilité :
\begin{itemize}
    \item Tout d'abord comme suggéré dans le sujet nous aurons une liste avec les variables de notre formule qui seront alors chacune associée à un quantificateur existentiel car les hypothèses pour la procédure de décision seront déjà satisfaites à cette étape. Par exemple pour la formule suivante $\exists x\,\exists y\,\exists z\,\varphi$ nous aurons la liste [x,y,z] dans cette ordre pour pouvoir éliminer les quantificateurs à partir du dernier élément de la liste jusqu'au premier. Cet ordre est simplement pour une meilleure compréhension car en python nous pouvons accéder facilement au dernier élément d'une liste, sinon nous aurons inversé l'ordre pour l'utiliser comme une pile en ajoutant les variables à partir du début de la formule. De même, la liste ne sera pas exactement celle-ci mais plutôt [sub=QuantifF(q=Ex(), var='x', body=None), QuantifF(q=Ex(), var='y', body=None), QuantifF(q=Ex(), var='z', body=None)], de ce fait nous pourrons rajouter les négations dans cette liste.\\
\end{itemize}

Ensuite nous avons penser à une suite de cette représentation qui sera possible juste après avoir tiré les négations à l'intérieur de notre formule. Nous aurons besoin deux dictionnaires pour cela :

\begin{itemize}
    \item Le premier dictionnaire que nous appellerons dicoEqual sera composé de toute les égalités de la formule ou sous-formule étudié.\\
    \item Dans le même style que le premier nous aurons le dictionnaire dicoLeft qui sera composé de toute les inégalités de la formule ou d'une sous-formule.
\end{itemize}

Pour les cas simple ces deux dictionnaires suffisent mais dès lors que nous aurons des formules constituées de $\lor$ et de $\land$ nous devrons séparer notre formule en sous formule pour les résoudre les unes après les autres. 
Lorsque nous rencontrons un $\land$ nous pouvons mettre l'égalité ou l'inégalité dans le même dictionnaire mais si nous avons un $\lor$ il faut alors extraire les deux sous formules et créer les deux dictionnaires pour chacun afin de résoudre cela.

\end{document}